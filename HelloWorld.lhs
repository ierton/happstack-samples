Сейчас я буду делиться впечатлениями от использования Haskell для разработки web-приложений. Конечно, этот hello-world можно назвать web-приложением лишь с некоторой улыбкой, но я надеюсь, что простоту и легкость процесса разработки можно будет ощутить даже на таком простом примере.

В языке Haskell имеется несколько библиотек для разработки web-ориентированных программ. Среди них можно выделить FastCGI и Happstack (потомок более старой библиотеки Happs). Программы, созданные с помощью FastCGI потребуют внешенего сервера, такого как apache, в то время как Happstack позволяет строить самодостаточные приложения, открывающие порт и выполняющие всю работу по обработке запросов пользователя. В данном примере будет использоваться именно Happstack.

Для того, чтобы испытать программу, можно скопировать весь текст статьи (прямо вместе с русскими буквами:) в файл с именем HelloWorld.lhs и запустить интерпретатор:

	ghci HelloWorld.lhs
	main

Итак, приступим:

Вначале несколько объявлений, необходимых опций компилятора и используемых модулей.

> {-# OPTIONS_GHC -F -pgmF trhsx #-}

> import Happstack.Server
> import HSP 
> import Data.Char
> import HSP.ServerPartT

Далее, основная программа.

> main :: IO ()
> main = do
>   let cfg = Conf { validator = Nothing, port = 3333 }
>   simpleHTTP cfg handlerMap

Функция simpleHTTP осуществляет запуск сервера в простейшей (а также, наиболее используемой) конфигурации. В качестве параметров передаём порт 3333. 

В качестве второго аргумента передаётся функция, обрабатывающая запросы пользователей. Её задача - различать GET и POST запросы, получать их параметры и формировать ответ.

> handlerMap :: ServerPartT IO Response
> handlerMap = do
>   xhello <- unXMLGenT (hello "World")
>   makeResponse xhello

> makeResponse = ok . setHeader "Content-Type" "text/html" . 
>   toResponse . renderAsHTML

Здесь необходимо пояснение. Начнем с типа. Функция должна вернуть монаду ServerPartT IO, содержащую Response. Response - это тот самый ответ пользователю, который мы должны вернуть. В простейшем случае он состоит из заголовков и тела (HTML кода). Первая строчка функции (xhello <- ...) создает HTML (точнее, XML). Вторая - "добавляет" в него поля заголовков.

TODO: Написать про монаду

Теперь дело за малым - сгенерировать  HTML код. Задача на первый взгляд очень проста, однако люди решают её совершенно разными методами, периодически создавая новые. Существует большое количество инструментов, использующих загружаемые шаблоны (подход PHP, Java template library). Существуют специальные "переходные" языки (например, ). Авторы некоторых приложений переносят эту задачу на пользователя, применяя JavaScript-библиотеки, подобные (TODO: проверить Mustache). 

В данном примере используется другой подход: с помощью специального расширения ghc (обратите внимание на строку OPTIONS_GHC в начале файла), в синтаксис Haskell добавляется поддержка XML, что позволяет с одной стороны максимально укоротить код приложения, а с другой - воспользоваться преимуществами статической проверки типов при подстановке параметров. 

> hello :: String -> XMLGenT (ServerPartT IO) XML
> hello noun =
>     <html>
>      <head>
>       <title>Hello, <% noun %></title>
>      </head>
>      <body>
>       <p>Hello, <% map toUpper noun %></p>
>      </body>
>     </html>

Всё, программа готова. Надеюсь, количество кода и легкость разработки говорят сами за себя. После запуска main, откройте в браузере [http://127.0.0.1:3333](http://127.0.0.1:3333) чтобы увидеть долгожданную фразу.

### Ссылки

* [Happstack project blog](http://happstack.wordpress.com/)
* [Proxying Happstack](http://huygens.functor.nl/blog/?p=21)

